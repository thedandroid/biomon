---
phase: 02-type-definitions
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/state.ts
  - src/types/tables.ts
  - src/types/events.ts
  - src/types/index.ts
autonomous: true

must_haves:
  truths:
    - "Type files compile without errors via npm run typecheck"
    - "All types can be imported from src/types/"
    - "No runtime code exists in type files"
    - "Socket.io event maps have full payload shapes"
  artifacts:
    - path: "src/types/state.ts"
      provides: "Core state interfaces (GameState, Player, Effect, RollEvent, LogEntry, SessionMetadata)"
      exports: ["GameState", "Player", "Effect", "LastRollEvent", "RollEvent", "LogEntry", "SessionMetadata", "RollType", "LogEntryType", "DurationType", "ApplyOption"]
    - path: "src/types/tables.ts"
      provides: "Response table types (TableEntry, ApplyOption)"
      exports: ["TableEntry"]
    - path: "src/types/events.ts"
      provides: "Socket.io event maps and payload types"
      exports: ["ClientToServerEvents", "ServerToClientEvents", "TypedServer", "TypedSocket", "TypedExternalNamespace"]
    - path: "src/types/index.ts"
      provides: "Barrel export for all types"
      contains: "export * from"
  key_links:
    - from: "src/types/events.ts"
      to: "src/types/state.ts"
      via: "import type { GameState }"
      pattern: "import type.*from.*state"
    - from: "src/types/index.ts"
      to: "src/types/state.ts"
      via: "barrel export"
      pattern: "export \\* from"
    - from: "src/types/index.ts"
      to: "src/types/tables.ts"
      via: "barrel export"
      pattern: "export \\* from"
    - from: "src/types/index.ts"
      to: "src/types/events.ts"
      via: "barrel export"
      pattern: "export \\* from"
---

<objective>
Create central type definitions that serve as contracts between modules.

Purpose: Establish the type foundation that all subsequent TypeScript migration phases depend on. These pure type files define the shapes of GameState, Players, Effects, Events, and Socket.io event maps without any runtime code.

Output: Four TypeScript files in `src/types/` containing all shared type definitions, compilable via `npm run typecheck`.
</objective>

<execution_context>
@/Users/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-type-definitions/02-RESEARCH.md
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create state and table type definitions</name>
  <files>src/types/state.ts, src/types/tables.ts</files>
  <action>
Create `src/` directory (project source directory for TypeScript files), then create `src/types/` subdirectory:

```bash
mkdir -p src/types
```

Create two type files:

**src/types/state.ts** (~90 lines):
Define all core state interfaces from the research document:
- Type aliases: `RollType = 'stress' | 'panic'`, `LogEntryType = 'info' | 'stress' | 'panic' | 'health' | 'system'`, `DurationType = 'manual'`
- `ApplyOption` interface with `tableEntryId: string` and `label: string`
- `Effect` interface (id, type, label, severity, createdAt, durationType, durationValue?, clearedAt)
- `LastRollEvent` interface with all 26 fields from research (type, eventId, total, die, stress, resolve, modifiers, tableEntryId, tableEntryLabel, tableEntryDescription, tableEntryStressDelta, tableEntryPersistent, duplicateAdjusted, duplicateFromId, duplicateFromLabel, duplicateNote, applyOptions, appliedTableEntryId, appliedTableEntryLabel, appliedTableEntryDescription, appliedTableEntryStressDelta, timestamp, applied, appliedEffectId, appliedStressDuplicate, stressDeltaApplied, stressDeltaAppliedValue)
- `Player` interface (id, name, health, maxHealth, stress, resolve, activeEffects, lastRollEvent)
- `RollEvent` interface (eventId, playerId, rollType, die, stress, resolve, modifiers, total, tableEntryId, label, description, stressDelta, duplicateAdjusted, duplicateFromId, duplicateFromLabel, timestamp)
- `LogEntry` interface (id, timestamp, type, message, details)
- `SessionMetadata` interface (campaignName, createdAt, lastSaved, sessionCount)
- `GameState` interface (players, rollEvents, missionLog, metadata)

All interfaces and types must be exported. Use `| null` for fields that are explicitly null (clearedAt, lastRollEvent, duplicateFromId, etc.) and `?:` for optional fields (durationValue).

**src/types/tables.ts** (~35 lines):
Define response table types:
- `TableEntry` interface with fields: min, max, id, label, description, severity, persistent, durationType?, durationValue?, stressDelta?, applyOptions?
- Import `ApplyOption` from state.ts using `import type`

Use only `type`, `interface`, and `export` - NO runtime code (no functions, no const values, no class implementations).
  </action>
  <verify>
Run `npm run typecheck` - should pass with no errors.
Verify files contain only type definitions: `grep -c "^export " src/types/state.ts src/types/tables.ts` should show export counts.
Verify no runtime code: `grep -E "^(const|let|var|function|class) " src/types/state.ts src/types/tables.ts` should return nothing.
  </verify>
  <done>
- src/types/state.ts exists with GameState, Player, Effect, LastRollEvent, RollEvent, LogEntry, SessionMetadata exported
- src/types/tables.ts exists with TableEntry exported
- Both files compile without errors
- No runtime code in either file
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Socket.io event maps and barrel export</name>
  <files>src/types/events.ts, src/types/index.ts</files>
  <action>
Create two more type files:

**src/types/events.ts** (~120 lines):
Define Socket.io event maps and payload types from research:

Payload interfaces (all exported):
- `PlayerAddPayload` { name?, maxHealth?, health?, stress?, resolve? } - all optional
- `PlayerUpdatePayload` { id, name?, maxHealth?, health?, stress?, resolve? } - id required
- `RollTriggerPayload` { playerId, rollType?, modifiers? }
- `RollApplyPayload` { playerId, eventId, tableEntryId? }
- `RollEventRef` { playerId, eventId }
- `EffectClearPayload` { playerId, effectId }
- `ConditionTogglePayload` { playerId, condition: 'fatigue' } - literal type for condition
- `SessionSavePayload` { campaignName? }
- `SessionLoadPayload` { filename }

Response interfaces (all exported):
- `SaveResult` { success, filename?, error? }
- `LoadResult` { success, error? }
- `ImportResult` { success, error? }
- `CampaignInfo` { filename, campaignName, lastSaved, playerCount, sessionCount }
- `AutosaveInfo` { found, timestamp?, playerCount?, campaignName? }

Event map interfaces (all exported):
- `ClientToServerEvents` - 17 events mapped to `(payload: T) => void` or `() => void`
- `ServerToClientEvents` - 7 events mapped to response types
- `ExternalClientToServerEvents` - empty (read-only namespace)
- `ExternalServerToClientEvents` - only 'state' event

Type aliases (all exported):
- `TypedServer = Server<ClientToServerEvents, ServerToClientEvents>`
- `TypedSocket = Socket<ClientToServerEvents, ServerToClientEvents>`
- `TypedExternalNamespace = Namespace<ExternalClientToServerEvents, ExternalServerToClientEvents>`

Import `type { Server, Socket, Namespace }` from 'socket.io'.
Import `type { GameState }` from './state.js' (use .js extension per moduleResolution: Bundler).

**src/types/index.ts** (~5 lines):
Barrel export all types:
```typescript
export * from './state.js';
export * from './tables.js';
export * from './events.js';
```

Use .js extensions in all imports (moduleResolution: Bundler pattern).
  </action>
  <verify>
Run `npm run typecheck` - should pass with no errors.
Test import works: Create a temp file that imports from src/types and run typecheck.
Verify Socket.io types are used: `grep "Server<" src/types/events.ts` should show TypedServer definition.
  </verify>
  <done>
- src/types/events.ts exists with ClientToServerEvents, ServerToClientEvents, TypedServer, TypedSocket exported
- src/types/index.ts exists with barrel exports from all three type files
- All files compile without errors via npm run typecheck
- Imports from 'socket.io' resolve correctly
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Type compilation:**
   ```bash
   npm run typecheck
   ```
   Must pass with zero errors.

2. **Export verification:**
   ```bash
   # Check all expected exports exist
   grep "^export" src/types/state.ts src/types/events.ts src/types/tables.ts src/types/index.ts
   ```

3. **No runtime code:**
   ```bash
   # Should return empty - no runtime code in type files
   grep -E "^(const|let|var|function |class )" src/types/*.ts
   ```

4. **Import chain works:**
   ```bash
   # Verify imports resolve
   echo "import type { GameState, Player, TypedServer, TypedSocket, TableEntry } from './src/types/index.js';" > /tmp/test-import.ts
   npx tsc --noEmit /tmp/test-import.ts --moduleResolution Bundler --module ESNext
   rm /tmp/test-import.ts
   ```
</verification>

<success_criteria>
- [ ] `npm run typecheck` passes with zero errors
- [ ] All 4 type files exist in src/types/
- [ ] GameState, Player, Effect, TypedServer, TypedSocket, TableEntry all importable from src/types/
- [ ] No runtime code in any type file (pure type definitions only)
- [ ] Socket.io event maps define all 17 client-to-server events with full payload shapes
- [ ] Socket.io event maps define all 7 server-to-client events with response shapes
</success_criteria>

<output>
After completion, create `.planning/phases/02-type-definitions/02-01-SUMMARY.md` following the summary template.
</output>
