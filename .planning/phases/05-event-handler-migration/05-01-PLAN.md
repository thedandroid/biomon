---
phase: 05-event-handler-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/handlers/types.ts
  - src/handlers/playerHandlers.ts
  - src/handlers/index.ts
autonomous: true

must_haves:
  truths:
    - "Handler types interface defines shared dependency contract"
    - "Player handlers register 4 events with exact runtime validation preserved"
    - "All optional chaining and nullish coalescing sites unchanged"
  artifacts:
    - path: "src/handlers/types.ts"
      provides: "HandlerDependencies interface"
      exports: ["HandlerDependencies"]
    - path: "src/handlers/playerHandlers.ts"
      provides: "Player and party event registration"
      exports: ["registerPlayerHandlers"]
    - path: "src/handlers/index.ts"
      provides: "Barrel export for handlers"
      exports: ["registerPlayerHandlers", "HandlerDependencies"]
  key_links:
    - from: "src/handlers/playerHandlers.ts"
      to: "src/types/events.ts"
      via: "TypedServer, TypedSocket imports"
      pattern: "import.*TypedServer.*TypedSocket"
---

<objective>
Create handler infrastructure and extract player/party handlers from server.js

Purpose: Establish the modular handler pattern and extract the first handler module, providing a template for subsequent handler extractions.
Output: src/handlers/ directory with types.ts, playerHandlers.ts, and barrel export
</objective>

<execution_context>
@/Users/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-event-handler-migration/05-RESEARCH.md

# Source files
@server.js (lines 314-394 for player/party handlers)
@src/types/events.ts (TypedServer, TypedSocket)
@src/types/state.ts (GameState, Player)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create handler types and infrastructure</name>
  <files>src/handlers/types.ts, src/handlers/index.ts</files>
  <action>
Create `src/handlers/types.ts` with HandlerDependencies interface:

```typescript
import type { TypedServer, TypedSocket } from "../types/index.js";
import type { GameState, RollType, Player } from "../types/index.js";

export interface HandlerDependencies {
  // State mutation helpers
  broadcast: () => void;
  addLogEntry: (type: string, message: string, details?: string | null) => void;
  scheduleSave: () => void;

  // Player utilities
  ensurePlayerFields: (player: Player) => void;

  // Validation utilities
  clamp: (val: number, min: number, max: number) => number;
  clampInt: (val: number, min: number, max: number) => number;

  // ID generation
  newId: () => string;

  // Roll utilities (for rollHandlers)
  d6: () => number;
  hasLiveEffect: (player: Player, effectId: string) => boolean;
  resolveEntry: (rollType: RollType, total: number) => any;
  getEntryById: (rollType: RollType, id: string) => any;
  resolveNextHigherDifferentEntry: (rollType: RollType, total: number, currentId: string) => any;
  pushRollEvent: (event: any) => void;

  // Constants
  DEFAULT_MAX_HEALTH: number;
  MAX_HEALTH_CAP: number;
  MAX_STRESS: number;
  MAX_RESOLVE: number;
}

// Re-export socket types for handler modules
export type { TypedServer, TypedSocket, GameState, Player, RollType };
```

Create `src/handlers/index.ts` barrel export (will grow as handlers added):

```typescript
export * from "./types.js";
export * from "./playerHandlers.js";
```

Note: Use `.js` extensions for imports (Bundler moduleResolution handles .ts resolution).
  </action>
  <verify>npm run typecheck passes with new type files</verify>
  <done>HandlerDependencies interface exported, barrel export created</done>
</task>

<task type="auto">
  <name>Task 2: Create playerHandlers module</name>
  <files>src/handlers/playerHandlers.ts</files>
  <action>
Create `src/handlers/playerHandlers.ts` extracting handlers from server.js lines 314-394:

```typescript
import type { TypedServer, TypedSocket, GameState, HandlerDependencies } from "./types.js";

export function registerPlayerHandlers(
  io: TypedServer,
  socket: TypedSocket,
  state: GameState,
  deps: HandlerDependencies
): void {
  // player:add - lines 314-338
  socket.on("player:add", (payload) => {
    const name =
      String(payload?.name ?? "")
        .trim()
        .slice(0, 40) || "UNNAMED";
    const maxHealth = deps.clamp(
      payload?.maxHealth ?? deps.DEFAULT_MAX_HEALTH,
      1,
      deps.MAX_HEALTH_CAP
    );

    state.players.push({
      id: deps.newId(),
      name,
      maxHealth,
      health: deps.clamp(payload?.health ?? maxHealth, 0, maxHealth),
      stress: deps.clamp(payload?.stress ?? 0, 0, deps.MAX_STRESS),
      resolve: deps.clamp(payload?.resolve ?? 0, 0, deps.MAX_RESOLVE),
      activeEffects: [],
      lastRollEvent: null,
    });

    deps.addLogEntry("system", `CREW MEMBER ADDED: ${name}`);
    deps.broadcast();
  });

  // player:remove - lines 340-348
  socket.on("player:remove", (payload) => {
    const id = String(payload?.id ?? "");
    const p = state.players.find((x) => x.id === id);
    const name = p ? p.name : "UNKNOWN";

    state.players = state.players.filter((p) => p.id !== id);
    deps.addLogEntry("system", `CREW MEMBER REMOVED: ${name}`);
    deps.broadcast();
  });

  // player:update - lines 350-386
  socket.on("player:update", (payload) => {
    const id = String(payload?.id ?? "");
    const p = state.players.find((x) => x.id === id);
    if (!p) return;

    deps.ensurePlayerFields(p);

    if (payload?.name !== undefined)
      p.name = String(payload.name).trim().slice(0, 40) || p.name;

    if (payload?.maxHealth !== undefined) {
      p.maxHealth = deps.clamp(payload.maxHealth, 1, deps.MAX_HEALTH_CAP);
      if (p.health > p.maxHealth) p.health = p.maxHealth;
    }

    if (payload?.health !== undefined) {
      const maxH = deps.clamp(p.maxHealth ?? deps.DEFAULT_MAX_HEALTH, 1, deps.MAX_HEALTH_CAP);
      const oldHealth = p.health;
      p.health = deps.clamp(payload.health, 0, maxH);

      if (p.health !== oldHealth) {
        if (p.health === 0) {
          deps.addLogEntry("health", `${p.name} CRITICAL: HEALTH DROPPED TO 0`);
        }
      }
    }

    if (payload?.stress !== undefined)
      p.stress = deps.clamp(payload.stress, 0, deps.MAX_STRESS);

    if (payload?.resolve !== undefined)
      p.resolve = deps.clamp(payload.resolve, 0, deps.MAX_RESOLVE);

    deps.broadcast();
  });

  // party:clear - lines 388-394
  socket.on("party:clear", () => {
    state.players = [];
    state.rollEvents = [];
    state.missionLog = [];
    deps.addLogEntry("system", "PARTY CLEARED");
    deps.broadcast();
  });
}
```

CRITICAL: Preserve ALL runtime validation exactly:
- `String(payload?.name ?? "")` - type coercion + optional chaining + nullish coalescing
- `.trim().slice(0, 40)` - string sanitization
- `deps.clamp()` - range validation
- `if (!p) return` - guard clauses

Do NOT remove or simplify any validation - TypeScript types are compile-time only.
  </action>
  <verify>npm run typecheck passes; npm run lint passes; npm test passes (existing tests don't use handlers directly yet)</verify>
  <done>playerHandlers.ts exports registerPlayerHandlers with 4 event handlers, all validation preserved</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Type check passes: `npm run typecheck`
2. Lint passes: `npm run lint`
3. All tests pass: `npm test`
4. Files exist with correct exports:
   - src/handlers/types.ts exports HandlerDependencies
   - src/handlers/playerHandlers.ts exports registerPlayerHandlers
   - src/handlers/index.ts re-exports both
</verification>

<success_criteria>
- Handler infrastructure established in src/handlers/
- HandlerDependencies interface captures all dependencies (utilities + constants)
- playerHandlers.ts contains exact handler logic from server.js
- All optional chaining (?.) and nullish coalescing (??) preserved
- TypeScript compiles without errors
- Pattern established for subsequent handler extractions
</success_criteria>

<output>
After completion, create `.planning/phases/05-event-handler-migration/05-01-SUMMARY.md`
</output>
