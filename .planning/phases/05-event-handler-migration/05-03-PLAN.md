---
phase: 05-event-handler-migration
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - src/handlers/effectHandlers.ts
  - src/handlers/conditionHandlers.ts
  - src/handlers/sessionHandlers.ts
  - src/handlers/externalHandlers.ts
  - src/handlers/index.ts
autonomous: true

must_haves:
  truths:
    - "Effect handler clears effects and un-applies related roll events"
    - "Condition handler toggles fatigue with validation"
    - "Session handlers manage save/load/list/clear/export/import"
    - "External handler sets up read-only namespace"
    - "All runtime validation preserved in every handler"
  artifacts:
    - path: "src/handlers/effectHandlers.ts"
      provides: "Effect clear handler"
      exports: ["registerEffectHandlers"]
    - path: "src/handlers/conditionHandlers.ts"
      provides: "Condition toggle handler"
      exports: ["registerConditionHandlers"]
    - path: "src/handlers/sessionHandlers.ts"
      provides: "Session management handlers (6 events)"
      exports: ["registerSessionHandlers"]
    - path: "src/handlers/externalHandlers.ts"
      provides: "External namespace handler"
      exports: ["registerExternalHandlers"]
  key_links:
    - from: "src/handlers/sessionHandlers.ts"
      to: "server.js persistence functions"
      via: "SessionDependencies interface"
      pattern: "saveCampaign|loadCampaign|listCampaigns|clearSession"
---

<objective>
Extract effect, condition, session, and external handlers from server.js

Purpose: Complete handler extraction by migrating remaining 9 event handlers (effect:clear, condition:toggle, 6 session events, external namespace).
Output: Four handler modules completing the src/handlers/ structure
</objective>

<execution_context>
@/Users/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-event-handler-migration/05-RESEARCH.md

# Source files
@server.js (lines 716-878 for effect/condition/session/external handlers)
@src/types/events.ts (TypedServer, TypedSocket, TypedExternalNamespace)
@src/types/state.ts (GameState)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create effectHandlers and conditionHandlers</name>
  <files>src/handlers/effectHandlers.ts, src/handlers/conditionHandlers.ts</files>
  <action>
Create `src/handlers/effectHandlers.ts` from server.js lines 716-741:

```typescript
import type { TypedServer, TypedSocket, GameState, HandlerDependencies } from "./types.js";

export function registerEffectHandlers(
  io: TypedServer,
  socket: TypedSocket,
  state: GameState,
  deps: HandlerDependencies
): void {
  // effect:clear - lines 716-741
  socket.on("effect:clear", (payload) => {
    const playerId = String(payload?.playerId ?? "");
    const effectId = String(payload?.effectId ?? "");

    const p = state.players.find((x) => x.id === playerId);
    if (!p) return;
    deps.ensurePlayerFields(p);

    const eff = p.activeEffects.find((e) => e.id === effectId);
    if (!eff) return;
    if (!eff.clearedAt) eff.clearedAt = Date.now();

    // If this effect was attached to the last roll event, un-apply that roll.
    if (p.lastRollEvent && p.lastRollEvent.appliedEffectId === effectId) {
      p.lastRollEvent.applied = false;
      p.lastRollEvent.appliedEffectId = null;
      p.lastRollEvent.appliedTableEntryId = null;
      p.lastRollEvent.appliedTableEntryLabel = null;
      p.lastRollEvent.appliedTableEntryDescription = null;
      p.lastRollEvent.appliedTableEntryStressDelta = null;
    }

    console.log(`[EFFECT:CLEAR] ${p.name} effect=${eff.type} (${eff.id})`);
    deps.addLogEntry("info", `${p.name} CONDITION CLEARED: ${eff.label}`);
    deps.broadcast();
  });
}
```

Create `src/handlers/conditionHandlers.ts` from server.js lines 743-782:

```typescript
import type { TypedServer, TypedSocket, GameState, HandlerDependencies } from "./types.js";

export function registerConditionHandlers(
  io: TypedServer,
  socket: TypedSocket,
  state: GameState,
  deps: HandlerDependencies
): void {
  // condition:toggle - lines 743-782
  socket.on("condition:toggle", (payload) => {
    const playerId = String(payload?.playerId ?? "");
    const condition = String(payload?.condition ?? "").toLowerCase();

    // Validate condition name - Only "fatigue" is supported now
    const VALID_CONDITIONS = ["fatigue"];
    if (!VALID_CONDITIONS.includes(condition)) return;

    const p = state.players.find((x) => x.id === playerId);
    if (!p) return;
    deps.ensurePlayerFields(p);

    const type = `condition_${condition}`;
    const label = condition.toUpperCase();

    // Check if already active (and not cleared)
    const existing = (p.activeEffects || []).find((e) => e.type === type && !e.clearedAt);

    if (existing) {
      // Toggle OFF
      existing.clearedAt = Date.now();
      console.log(`[CONDITION:REMOVE] ${p.name} ${condition}`);
      deps.addLogEntry("info", `${p.name} RECOVERED FROM: ${label}`);
    } else {
      // Toggle ON
      const effect = {
        id: deps.newId(),
        type,
        label,
        severity: 1,
        createdAt: Date.now(),
        durationType: "manual",
        clearedAt: null,
      };
      p.activeEffects.push(effect);
      console.log(`[CONDITION:ADD] ${p.name} ${condition}`);
      deps.addLogEntry("info", `${p.name} IS NOW FATIGUED`);
    }
    deps.broadcast();
  });
}
```
  </action>
  <verify>npm run typecheck passes for new handler files</verify>
  <done>effectHandlers.ts and conditionHandlers.ts created with exact validation logic</done>
</task>

<task type="auto">
  <name>Task 2: Create sessionHandlers</name>
  <files>src/handlers/sessionHandlers.ts</files>
  <action>
Create `src/handlers/sessionHandlers.ts` from server.js lines 784-855.

Session handlers need additional dependencies for persistence functions. Add to HandlerDependencies interface (will be wired in plan 04):

```typescript
import type { TypedServer, TypedSocket, GameState, HandlerDependencies } from "./types.js";
import type { AutosaveInfo, CampaignInfo, SaveResult, LoadResult, ImportResult } from "../types/index.js";

// Extended dependencies for session handlers
export interface SessionDependencies extends HandlerDependencies {
  saveCampaign: (campaignName: string) => SaveResult;
  loadCampaign: (filename: string) => LoadResult;
  listCampaigns: () => CampaignInfo[];
  clearSession: () => void;
  autosaveInfo: AutosaveInfo;
}

export function registerSessionHandlers(
  io: TypedServer,
  socket: TypedSocket,
  state: GameState,
  deps: SessionDependencies
): void {
  // session:save - lines 788-796
  socket.on("session:save", (payload) => {
    const campaignName = String(payload?.campaignName || "").trim() || "unnamed";
    const result = deps.saveCampaign(campaignName);
    socket.emit("session:save:result", result);
    if (result.success) {
      deps.addLogEntry("system", `CAMPAIGN SAVED: ${campaignName}`);
      deps.broadcast();
    }
  });

  // session:load - lines 798-810
  socket.on("session:load", (payload) => {
    const filename = String(payload?.filename || "").trim();
    if (!filename) {
      socket.emit("session:load:result", { success: false, error: "No filename provided" });
      return;
    }
    const result = deps.loadCampaign(filename);
    socket.emit("session:load:result", result);
    if (result.success) {
      deps.addLogEntry("system", `CAMPAIGN LOADED: ${state.metadata.campaignName || filename}`);
      deps.broadcast();
    }
  });

  // session:list - lines 812-815
  socket.on("session:list", () => {
    const campaigns = deps.listCampaigns();
    socket.emit("session:list:result", campaigns);
  });

  // session:clear - lines 817-821
  socket.on("session:clear", () => {
    deps.clearSession();
    deps.addLogEntry("system", "SESSION CLEARED");
    deps.broadcast();
  });

  // session:export - lines 823-825
  socket.on("session:export", () => {
    socket.emit("session:export:result", state);
  });

  // session:import - lines 827-851
  socket.on("session:import", (payload) => {
    try {
      if (!payload || typeof payload !== "object") {
        socket.emit("session:import:result", { success: false, error: "Invalid data" });
        return;
      }

      state.players = Array.isArray(payload.players) ? payload.players : [];
      state.rollEvents = Array.isArray(payload.rollEvents) ? payload.rollEvents : [];
      state.missionLog = Array.isArray(payload.missionLog) ? payload.missionLog : [];
      state.metadata = payload.metadata || {
        campaignName: null,
        createdAt: new Date().toISOString(),
        lastSaved: null,
        sessionCount: 0,
      };

      for (const p of state.players) deps.ensurePlayerFields(p);

      socket.emit("session:import:result", { success: true });
      deps.broadcast();
    } catch (err) {
      const error = err instanceof Error ? err.message : "Unknown error";
      socket.emit("session:import:result", { success: false, error });
    }
  });

  // Send autosave info to GM on connection - line 854
  socket.emit("session:autosave:info", deps.autosaveInfo);
}
```

Note: SessionDependencies extends HandlerDependencies with persistence-specific functions. This keeps the base interface clean while allowing session handlers access to file operations.
  </action>
  <verify>npm run typecheck passes</verify>
  <done>sessionHandlers.ts created with 6 event handlers and SessionDependencies interface</done>
</task>

<task type="auto">
  <name>Task 3: Create externalHandlers and update barrel export</name>
  <files>src/handlers/externalHandlers.ts, src/handlers/index.ts</files>
  <action>
Create `src/handlers/externalHandlers.ts` from server.js lines 857-878:

```typescript
import type { TypedServer, GameState, HandlerDependencies } from "./types.js";

export function registerExternalHandlers(
  io: TypedServer,
  state: GameState,
  deps: Pick<HandlerDependencies, "ensurePlayerFields">
): void {
  // External namespace for read-only access
  const externalNamespace = io.of("/external");

  externalNamespace.on("connection", (socket) => {
    console.log(`[EXTERNAL] Client connected: ${socket.id}`);

    // Send initial state on connection
    for (const p of state.players) deps.ensurePlayerFields(p);
    socket.emit("state", state);

    socket.on("disconnect", (reason) => {
      console.log(`[EXTERNAL] Client disconnected: ${socket.id} (${reason})`);
    });

    // External namespace intentionally has no event handlers
    // It only receives broadcasts, providing true read-only access
  });
}
```

Note: External handlers use `Pick<HandlerDependencies, "ensurePlayerFields">` since they only need that one utility function. This maintains type safety while being explicit about dependencies.

Update `src/handlers/index.ts` to export all handlers:

```typescript
export * from "./types.js";
export * from "./playerHandlers.js";
export * from "./rollHandlers.js";
export * from "./effectHandlers.js";
export * from "./conditionHandlers.js";
export * from "./sessionHandlers.js";
export * from "./externalHandlers.js";
```
  </action>
  <verify>npm run typecheck passes; npm run lint passes; npm test passes</verify>
  <done>All handler modules created, barrel export updated with all exports</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Type check passes: `npm run typecheck`
2. Lint passes: `npm run lint`
3. All tests pass: `npm test`
4. Files exist with correct exports:
   - src/handlers/effectHandlers.ts exports registerEffectHandlers
   - src/handlers/conditionHandlers.ts exports registerConditionHandlers
   - src/handlers/sessionHandlers.ts exports registerSessionHandlers, SessionDependencies
   - src/handlers/externalHandlers.ts exports registerExternalHandlers
   - src/handlers/index.ts re-exports all
</verification>

<success_criteria>
- All 4 handler modules created with exact logic from server.js
- SessionDependencies extends HandlerDependencies for persistence functions
- External handlers use minimal deps via Pick<>
- All 9 handlers registered: effect:clear, condition:toggle, 6 session events, external namespace
- All runtime validation preserved (?.  ??, String(), Array.isArray())
- TypeScript compiles without errors
- Handler extraction complete - ready for server.ts refactor
</success_criteria>

<output>
After completion, create `.planning/phases/05-event-handler-migration/05-03-SUMMARY.md`
</output>
