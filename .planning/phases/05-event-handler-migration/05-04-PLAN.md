---
phase: 05-event-handler-migration
plan: 04
type: execute
wave: 2
depends_on: ["05-01", "05-02", "05-03"]
files_modified:
  - server.ts
  - server.js
autonomous: true

must_haves:
  truths:
    - "server.ts is thin router (~350-400 LOC entry point with inline persistence)"
    - "All 18 event handlers registered via imported handler modules"
    - "All existing integration tests pass unchanged"
    - "Persistence functions remain inline in server.ts"
    - "External namespace receives state broadcasts via broadcast() function"
    - "Optional chaining preserved: runtime validation count matches or exceeds server.js"
  artifacts:
    - path: "server.ts"
      provides: "Typed server entry point with handler registration"
      min_lines: 300
      max_lines: 450
  key_links:
    - from: "server.ts"
      to: "src/handlers/index.ts"
      via: "Handler registration imports"
      pattern: "import.*register.*Handlers"
    - from: "server.ts"
      to: "createServer.ts"
      via: "Server factory"
      pattern: "createServer"
    - from: "server.ts broadcast()"
      to: "/external namespace"
      via: "State broadcast to external clients"
      pattern: 'io\.of\("/external"\)\.emit\("state"'
---

<objective>
Convert server.js to server.ts with handler registration pattern

Purpose: Transform monolithic 887-line server.js into typed thin router that delegates to handler modules, completing the Phase 5 extraction.
Output: server.ts with ~350-400 LOC (persistence inline per research, handlers delegated)
</objective>

<execution_context>
@/Users/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-event-handler-migration/05-RESEARCH.md
@.planning/phases/05-event-handler-migration/05-01-SUMMARY.md
@.planning/phases/05-event-handler-migration/05-02-SUMMARY.md
@.planning/phases/05-event-handler-migration/05-03-SUMMARY.md

# Source files
@server.js
@src/handlers/index.ts
@createServer.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create server.ts with handler registration</name>
  <files>server.ts</files>
  <action>
Create `server.ts` converting server.js to TypeScript with handler imports.

Structure (following thin router pattern):
1. Imports (path, fs, express, handlers, utilities, types)
2. Directory setup (isPackaged, dataDir, publicDir)
3. Server initialization (createServer)
4. Static routes
5. Persistence layer (KEEP INLINE - per research recommendation)
6. State initialization
7. Helper functions (broadcast, pushRollEvent, resolveNextHigherDifferentEntry, addLogEntry)
8. Dependencies object
9. Handler registration in io.on("connection")
10. External namespace registration
11. Server start

```typescript
// BIOMON - Biological Monitoring System
// Alien RPG Crew Vitals & Stress Monitor
import path from "path";
import { fileURLToPath } from "url";
import fs from "fs";
import express from "express";
import { createServer } from "./createServer.js";
import { resolveEntry, getEntryById } from "./responseTables.js";
import {
  clamp,
  clampInt,
  newId,
  ensurePlayerFields,
  hasLiveEffect,
  d6,
  DEFAULT_MAX_HEALTH,
  MAX_HEALTH_CAP,
  MAX_STRESS,
  MAX_RESOLVE,
  ROLL_FEED_CAP,
} from "./utils.js";
import {
  registerPlayerHandlers,
  registerRollHandlers,
  registerEffectHandlers,
  registerConditionHandlers,
  registerSessionHandlers,
  registerExternalHandlers,
} from "./src/handlers/index.js";
import type { SessionDependencies } from "./src/handlers/index.js";
import type { GameState, RollType, AutosaveInfo, SaveResult, LoadResult, CampaignInfo } from "./src/types/index.js";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// When running in pkg, use current working directory for data storage
const isPackaged = typeof process.pkg !== "undefined";
const dataDir = isPackaged ? process.cwd() : __dirname;

// Create server with CORS configuration
const corsOrigin = process.env.BIOMON_CORS_ORIGIN || "http://localhost:3051";
const { app, server, io } = createServer({ corsOrigin });

// Serve static files
const publicDir = isPackaged
  ? path.join(path.dirname(process.execPath), "public")
  : path.join(__dirname, "public");

app.use(express.static(publicDir));
app.get("/", (_req, res) => res.sendFile(path.join(publicDir, "player.html")));
app.get("/gm", (_req, res) => res.sendFile(path.join(publicDir, "gm.html")));

// ============================================================
// PERSISTENCE LAYER (kept inline per research recommendation)
// ============================================================

const SESSIONS_DIR = path.join(dataDir, "sessions");
const AUTOSAVE_PATH = path.join(SESSIONS_DIR, "autosave.json");
const AUTOSAVE_DEBOUNCE_MS = 1000;

if (!fs.existsSync(SESSIONS_DIR)) {
  fs.mkdirSync(SESSIONS_DIR, { recursive: true });
}
const ARCHIVED_DIR = path.join(SESSIONS_DIR, "archived");
if (!fs.existsSync(ARCHIVED_DIR)) {
  fs.mkdirSync(ARCHIVED_DIR, { recursive: true });
}

// Game state
const state: GameState = {
  players: [],
  rollEvents: [],
  missionLog: [],
  metadata: {
    campaignName: null,
    createdAt: null,
    lastSaved: null,
    sessionCount: 0,
  },
};

// Debounced auto-save
let saveTimeout: ReturnType<typeof setTimeout> | null = null;
function scheduleSave(): void {
  if (saveTimeout) clearTimeout(saveTimeout);
  saveTimeout = setTimeout(() => {
    try {
      state.metadata.lastSaved = new Date().toISOString();
      fs.writeFileSync(AUTOSAVE_PATH, JSON.stringify(state, null, 2), "utf8");
      console.log("[AUTOSAVE] State saved");
    } catch (err) {
      const message = err instanceof Error ? err.message : "Unknown error";
      console.error("[AUTOSAVE] Failed to save:", message);
    }
  }, AUTOSAVE_DEBOUNCE_MS);
}

// Load autosave on startup
function loadAutosave(): AutosaveInfo {
  try {
    if (fs.existsSync(AUTOSAVE_PATH)) {
      const data = fs.readFileSync(AUTOSAVE_PATH, "utf8");
      const loaded = JSON.parse(data) as GameState;

      state.players = Array.isArray(loaded.players) ? loaded.players : [];
      state.rollEvents = Array.isArray(loaded.rollEvents) ? loaded.rollEvents : [];
      state.missionLog = Array.isArray(loaded.missionLog) ? loaded.missionLog : [];
      state.metadata = loaded.metadata || {
        campaignName: null,
        createdAt: null,
        lastSaved: null,
        sessionCount: 0,
      };

      for (const p of state.players) ensurePlayerFields(p);

      const savedAt = state.metadata.lastSaved
        ? new Date(state.metadata.lastSaved).toLocaleString()
        : "unknown time";

      console.log(`[AUTOSAVE] Loaded previous session (saved: ${savedAt})`);
      console.log(`[AUTOSAVE] Players: ${state.players.length}, Campaign: ${state.metadata.campaignName || "unnamed"}`);

      return {
        found: true,
        timestamp: state.metadata.lastSaved ?? undefined,
        playerCount: state.players.length,
        campaignName: state.metadata.campaignName ?? undefined,
      };
    }
  } catch (err) {
    const message = err instanceof Error ? err.message : "Unknown error";
    console.error("[AUTOSAVE] Failed to load:", message);
  }

  state.metadata = {
    campaignName: null,
    createdAt: new Date().toISOString(),
    lastSaved: null,
    sessionCount: 0,
  };

  return { found: false };
}

const MAX_LOG_ENTRIES = 100;

function addLogEntry(type: string, message: string, details: string | null = null): void {
  const entry = {
    id: newId(),
    timestamp: Date.now(),
    type,
    message,
    details,
  };

  state.missionLog.unshift(entry);

  if (state.missionLog.length > MAX_LOG_ENTRIES) {
    state.missionLog = state.missionLog.slice(0, MAX_LOG_ENTRIES);
  }
}

function saveCampaign(campaignName: string): SaveResult {
  try {
    const safeName = campaignName.replace(/[^a-z0-9-_]/gi, "_").toLowerCase();
    const filename = `campaign-${safeName}.json`;
    const filepath = path.join(SESSIONS_DIR, filename);

    state.metadata.campaignName = campaignName;
    state.metadata.lastSaved = new Date().toISOString();
    state.metadata.sessionCount += 1;

    fs.writeFileSync(filepath, JSON.stringify(state, null, 2), "utf8");
    console.log(`[CAMPAIGN] Saved: ${filename}`);

    return { success: true, filename };
  } catch (err) {
    const message = err instanceof Error ? err.message : "Unknown error";
    console.error("[CAMPAIGN] Save failed:", message);
    return { success: false, error: message };
  }
}

function loadCampaign(filename: string): LoadResult {
  try {
    const filepath = path.join(SESSIONS_DIR, filename);
    if (!fs.existsSync(filepath)) {
      return { success: false, error: "File not found" };
    }

    const data = fs.readFileSync(filepath, "utf8");
    const loaded = JSON.parse(data) as GameState;

    state.players = Array.isArray(loaded.players) ? loaded.players : [];
    state.rollEvents = Array.isArray(loaded.rollEvents) ? loaded.rollEvents : [];
    state.missionLog = Array.isArray(loaded.missionLog) ? loaded.missionLog : [];
    state.metadata = loaded.metadata || {
      campaignName: null,
      createdAt: new Date().toISOString(),
      lastSaved: null,
      sessionCount: 0,
    };

    for (const p of state.players) ensurePlayerFields(p);

    console.log(`[CAMPAIGN] Loaded: ${filename}`);
    return { success: true };
  } catch (err) {
    const message = err instanceof Error ? err.message : "Unknown error";
    console.error("[CAMPAIGN] Load failed:", message);
    return { success: false, error: message };
  }
}

function listCampaigns(): CampaignInfo[] {
  try {
    const files = fs.readdirSync(SESSIONS_DIR);
    const campaigns = files
      .filter((f) => f.startsWith("campaign-") && f.endsWith(".json"))
      .map((filename) => {
        try {
          const filepath = path.join(SESSIONS_DIR, filename);
          const stats = fs.statSync(filepath);
          const data = JSON.parse(fs.readFileSync(filepath, "utf8")) as GameState;

          return {
            filename,
            campaignName: data.metadata?.campaignName || filename.replace("campaign-", "").replace(".json", ""),
            lastSaved: data.metadata?.lastSaved || stats.mtime.toISOString(),
            playerCount: data.players?.length || 0,
            sessionCount: data.metadata?.sessionCount || 0,
          };
        } catch {
          return null;
        }
      })
      .filter((c): c is CampaignInfo => c !== null)
      .sort((a, b) => new Date(b.lastSaved).getTime() - new Date(a.lastSaved).getTime());

    return campaigns;
  } catch (err) {
    const message = err instanceof Error ? err.message : "Unknown error";
    console.error("[CAMPAIGN] List failed:", message);
    return [];
  }
}

function clearSession(): void {
  state.players = [];
  state.rollEvents = [];
  state.missionLog = [];
  state.metadata = {
    campaignName: null,
    createdAt: new Date().toISOString(),
    lastSaved: null,
    sessionCount: 0,
  };
  console.log("[SESSION] Cleared");
}

// Load autosave on startup
const autosaveInfo = loadAutosave();

// ============================================================
// HELPER FUNCTIONS
// ============================================================

function pushRollEvent(ev: unknown): void {
  state.rollEvents.push(ev);
  if (state.rollEvents.length > ROLL_FEED_CAP) {
    state.rollEvents.splice(0, state.rollEvents.length - ROLL_FEED_CAP);
  }
}

function resolveNextHigherDifferentEntry(rollType: RollType, total: number, currentEntryId: string): unknown {
  const startId = String(currentEntryId ?? "");
  let t = clampInt(total, -999, 999);
  for (let i = 0; i < 25; i++) {
    t += 1;
    const next = resolveEntry(rollType, t);
    if (next && String(next.id ?? "") && String(next.id ?? "") !== startId)
      return next;
  }
  return null;
}

function broadcast(): void {
  for (const p of state.players) ensurePlayerFields(p);
  io.emit("state", state);
  io.of("/external").emit("state", state);
  scheduleSave();
}

// ============================================================
// HANDLER DEPENDENCIES
// ============================================================

const deps: SessionDependencies = {
  broadcast,
  addLogEntry,
  scheduleSave,
  ensurePlayerFields,
  clamp,
  clampInt,
  newId,
  d6,
  hasLiveEffect,
  resolveEntry,
  getEntryById,
  resolveNextHigherDifferentEntry,
  pushRollEvent,
  DEFAULT_MAX_HEALTH,
  MAX_HEALTH_CAP,
  MAX_STRESS,
  MAX_RESOLVE,
  saveCampaign,
  loadCampaign,
  listCampaigns,
  clearSession,
  autosaveInfo,
};

// ============================================================
// CONNECTION HANDLER
// ============================================================

io.on("connection", (socket) => {
  for (const p of state.players) ensurePlayerFields(p);
  socket.emit("state", state);

  // Register all handlers
  registerPlayerHandlers(io, socket, state, deps);
  registerRollHandlers(io, socket, state, deps);
  registerEffectHandlers(io, socket, state, deps);
  registerConditionHandlers(io, socket, state, deps);
  registerSessionHandlers(io, socket, state, deps);
});

// Register external namespace handlers
registerExternalHandlers(io, state, deps);

// ============================================================
// START SERVER
// ============================================================

const PORT = process.env.PORT || 3050;
server.listen(PORT, () => {
  console.log(`Party dashboard running on http://localhost:${PORT}`);
  console.log(`GM panel: http://localhost:${PORT}/gm`);
  if (autosaveInfo.found) {
    console.log(`[INFO] Previous session loaded. ${state.players.length} player(s) restored.`);
  }
});
```

CRITICAL: Keep persistence inline per research recommendation. Phase 5 focuses on handlers only.
  </action>
  <verify>npm run typecheck passes for server.ts</verify>
  <done>server.ts created with typed handler registration</done>
</task>

<task type="auto">
  <name>Task 2: Remove server.js and verify tests</name>
  <files>server.js</files>
  <action>
1. Delete server.js (replaced by server.ts)

```bash
rm server.js
```

2. Run full test suite to verify all integration tests pass:

```bash
npm test
```

Integration tests import from createServer.js which now has TypeScript backing, and tests should continue to work because:
- Tests don't directly import server.js - they use createServer
- Handler registration is internal to server.ts
- API behavior unchanged

3. Run typecheck to verify complete type coverage:

```bash
npm run typecheck
```

4. Run lint to check for issues:

```bash
npm run lint
```

5. Build and verify:

```bash
npm run build
```

If any test fails, debug and fix. Common issues:
- Import path changes (ensure .js extensions for Bundler resolution)
- Type mismatches in handler dependencies
- Missing re-exports from handlers index
  </action>
  <verify>npm test passes (79 tests); npm run typecheck passes; npm run build produces working executable</verify>
  <done>server.js deleted, server.ts is sole entry point, all tests pass</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. server.js deleted, server.ts exists
2. npm run typecheck passes
3. npm run lint passes
4. npm test passes (79 tests)
5. npm run build succeeds
6. server.ts is ~350-400 LOC (not 887 like original)
7. All handlers registered via imported modules

External namespace broadcast verification:
```bash
# Verify broadcast() includes external namespace emit
grep -n 'io.of("/external").emit' server.ts
# Should find: io.of("/external").emit("state", state) in broadcast()
```

Optional chaining preservation verification:
```bash
# Count optional chaining sites in server.js (baseline)
grep -c '\?\.' server.js 2>/dev/null || echo "server.js deleted"

# Count optional chaining in handlers + server.ts (should be >= original)
grep -c '\?\.' src/handlers/*.ts server.ts | tail -1
```

Final validation:
```bash
# Start server
npm start

# In another terminal, verify server responds
curl http://localhost:3050/
```
</verification>

<success_criteria>
- server.ts replaces server.js as entry point
- Thin router pattern achieved (~350-400 LOC vs 887, with inline persistence)
- All 18 event handlers registered via imported modules
- Persistence layer kept inline (to be extracted in future phase if needed)
- All 79 integration tests pass unchanged
- Build produces working executable
- No TypeScript errors or lint warnings
- broadcast() emits to both main namespace and /external namespace
- Optional chaining count in handlers + server.ts >= server.js original (53+)
</success_criteria></invoke>

<output>
After completion, create `.planning/phases/05-event-handler-migration/05-04-SUMMARY.md`
</output>
