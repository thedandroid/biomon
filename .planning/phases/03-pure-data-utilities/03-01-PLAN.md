---
phase: 03-pure-data-utilities
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - utils.ts
  - responseTables.ts
  - src/types/tables.ts
autonomous: true

must_haves:
  truths:
    - "utils.ts compiles without errors via npm run typecheck"
    - "responseTables.ts compiles without errors via npm run typecheck"
    - "Existing utils.test.js passes with typed utils.ts"
    - "Existing responseTables.test.js passes with typed responseTables.ts"
    - "No any types in converted files"
  artifacts:
    - path: "utils.ts"
      provides: "Typed utility functions and constants"
      exports: ["DEFAULT_MAX_HEALTH", "MAX_HEALTH_CAP", "MAX_STRESS", "MAX_RESOLVE", "ROLL_FEED_CAP", "clamp", "clampInt", "newId", "ensurePlayerFields", "hasLiveEffect", "d6"]
    - path: "responseTables.ts"
      provides: "Typed response tables and lookup functions"
      exports: ["STRESS_TABLE", "PANIC_TABLE", "resolveEntry", "getEntryById"]
    - path: "src/types/tables.ts"
      provides: "TableApplyOption type for raw table data"
      contains: "TableApplyOption"
  key_links:
    - from: "utils.ts"
      to: "src/types/index.js"
      via: "import type { Player }"
      pattern: "import type.*Player.*from.*src/types"
    - from: "responseTables.ts"
      to: "src/types/index.js"
      via: "import type { TableEntry, RollType }"
      pattern: "import type.*TableEntry.*from.*src/types"
---

<objective>
Convert utils.js and responseTables.js to TypeScript with full type coverage.

Purpose: Enable compile-time type checking for all utility functions and response tables, catching type mismatches before runtime. This is the first actual code conversion in the TypeScript migration.

Output: Two TypeScript files (utils.ts, responseTables.ts) with explicit type annotations on all functions and const assertions on table data, plus a minor type fix in src/types/tables.ts.
</objective>

<execution_context>
@/Users/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-pure-data-utilities/03-RESEARCH.md

# Source files to convert
@utils.js
@responseTables.js

# Types to import
@src/types/index.ts
@src/types/state.ts
@src/types/tables.ts

# Tests that must pass
@test/utils.test.js
@test/responseTables.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Convert utils.js to utils.ts</name>
  <files>utils.ts</files>
  <action>
Rename utils.js to utils.ts and add TypeScript type annotations:

1. Add type-only import for Player:
   ```typescript
   import type { Player } from "./src/types/index.js";
   ```

2. Add explicit type annotations to constants:
   ```typescript
   const DEFAULT_MAX_HEALTH: number = 5;
   const MAX_HEALTH_CAP: number = 10;
   const MAX_STRESS: number = 10;
   const MAX_RESOLVE: number = 10;
   const ROLL_FEED_CAP: number = 200;
   ```

3. Add parameter and return types to all functions:
   - `clamp(n: number, lo: number, hi: number): number`
   - `clampInt(n: number, lo: number, hi: number): number`
   - `newId(): string`
   - `ensurePlayerFields(p: Partial<Player> | null | undefined): void`
   - `hasLiveEffect(p: Pick<Player, "activeEffects"> | null | undefined, effectType: string): boolean`
   - `d6(): number`

4. Keep ALL runtime validation unchanged:
   - Keep `Number(n)` coercions
   - Keep `Number.isNaN()` checks
   - Keep `??` and `?.` operators
   - Keep `String()` coercions
   - Keep `Array.isArray()` checks

5. Delete the original utils.js after conversion.

Important: Do NOT simplify or remove defensive code. Types are compile-time only; runtime validation must remain.
  </action>
  <verify>
Run `npm run typecheck` - should pass with no errors.
Run `npm test -- test/utils.test.js` - all tests should pass.
Verify no `any` types: `grep -n "any" utils.ts` should return nothing or only comments.
  </verify>
  <done>
utils.ts exists with all functions typed, utils.js is deleted, typecheck passes, all utils tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Convert responseTables.js to responseTables.ts with type fix</name>
  <files>responseTables.ts, src/types/tables.ts</files>
  <action>
First, fix the type mismatch in src/types/tables.ts:

The current `TableEntry.applyOptions` uses `ApplyOption` which has `tableEntryId: string`, but the raw table data uses `id: string`. Add a separate type for the table's apply options:

```typescript
// In src/types/tables.ts, add before TableEntry:

/**
 * Apply option as stored in response tables (raw format).
 * Note: This differs from ApplyOption in state.ts which uses tableEntryId.
 * The transformation from id -> tableEntryId happens in server.js.
 */
export interface TableApplyOption {
  id: string;
  label: string;
}
```

Then update TableEntry to use it:
```typescript
applyOptions?: TableApplyOption[];  // Changed from ApplyOption[]
```

Now rename responseTables.js to responseTables.ts and add types:

1. Add type-only imports:
   ```typescript
   import type { TableEntry, RollType } from "./src/types/index.js";
   ```

2. Apply const assertion with type validation to both tables:
   ```typescript
   const STRESS_TABLE = [
     // ... existing entries unchanged
   ] as const satisfies readonly TableEntry[];

   const PANIC_TABLE = [
     // ... existing entries unchanged
   ] as const satisfies readonly TableEntry[];
   ```

3. Add parameter and return types to all functions:
   - `pickEntryByTotal(table: readonly TableEntry[], total: number): TableEntry`
   - `getTable(rollType: RollType | string): readonly TableEntry[]`
   - `resolveEntry(rollType: RollType | string, total: number): TableEntry`
   - `getEntryById(rollType: RollType | string, entryId: string | null | undefined): TableEntry | null`

4. Keep ALL runtime validation:
   - Keep `Number(total)` coercion
   - Keep `String(entryId ?? "")` coercion
   - Keep `|| null` fallback in getEntryById (change to `?? null` for consistency)

5. Delete the original responseTables.js after conversion.

Important: The `as const satisfies readonly TableEntry[]` pattern provides both literal type inference AND type validation. Use `readonly` because `as const` makes arrays immutable.
  </action>
  <verify>
Run `npm run typecheck` - should pass with no errors.
Run `npm test -- test/responseTables.test.js` - all tests should pass.
Verify no `any` types: `grep -n "any" responseTables.ts` should return nothing or only comments.
Verify TableApplyOption exists: `grep -n "TableApplyOption" src/types/tables.ts` should show the interface.
  </verify>
  <done>
responseTables.ts exists with typed tables and functions, src/types/tables.ts has TableApplyOption, responseTables.js is deleted, typecheck passes, all responseTables tests pass.
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Full typecheck passes:
   ```bash
   npm run typecheck
   ```

2. All tests pass:
   ```bash
   npm test
   ```

3. No any types in converted files:
   ```bash
   grep -rn ": any" utils.ts responseTables.ts
   # Should return nothing
   ```

4. Original JS files removed:
   ```bash
   ls utils.js responseTables.js 2>&1 | grep "No such file"
   # Should show both files don't exist
   ```

5. Type exports work:
   ```bash
   grep -n "TableApplyOption" src/types/tables.ts
   # Should show the export
   ```
</verification>

<success_criteria>
- utils.ts compiles with full type coverage (no `any`)
- responseTables.ts compiles with typed table entries and const assertions
- Existing tests import and pass with typed modules
- Functions have explicit parameter and return types
- Original .js files deleted
- TableApplyOption type added to distinguish from state's ApplyOption
</success_criteria>

<output>
After completion, create `.planning/phases/03-pure-data-utilities/03-01-SUMMARY.md`
</output>
