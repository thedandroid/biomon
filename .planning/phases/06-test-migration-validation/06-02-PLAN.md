---
phase: 06-test-migration-validation
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - test/server.integration.test.ts
autonomous: true

must_haves:
  truths:
    - "server.integration.test.ts compiles without TypeScript errors"
    - "All 21 integration tests pass"
    - "No any types in test file"
    - "Socket.IO client uses typed generics"
  artifacts:
    - path: "test/server.integration.test.ts"
      provides: "Typed Socket.IO integration tests"
      min_lines: 800
      contains: "TypedClientSocket"
  key_links:
    - from: "test/server.integration.test.ts"
      to: "src/types/events.ts"
      via: "type imports for event maps"
      pattern: "ClientToServerEvents|ServerToClientEvents"
    - from: "test/server.integration.test.ts"
      to: "src/types/state.ts"
      via: "type imports for GameState, Player"
      pattern: "import type.*GameState|Player"
---

<objective>
Migrate server integration test file to TypeScript with typed Socket.IO clients

Purpose: Convert the server integration test file (810 LOC, 21 tests) to TypeScript with properly typed Socket.IO client sockets, typed state objects, and typed event payloads. This establishes the pattern for external integration tests.

Output: server.integration.test.ts with typed Socket.IO client, typed GameState, and no `any` types.
</objective>

<execution_context>
@/Users/daniel/.claude/get-shit-done/workflows/execute-plan.md
@/Users/daniel/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-test-migration-validation/06-RESEARCH.md

@src/types/state.ts
@src/types/events.ts
@test/server.integration.test.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add type infrastructure to server.integration.test</name>
  <files>test/server.integration.test.ts</files>
  <action>
1. Rename test/server.integration.test.js to test/server.integration.test.ts

2. Add type imports at top of file:
```typescript
import { describe, it, expect, beforeAll, afterAll, beforeEach } from "vitest";
import { io as ioClient, type Socket as ClientSocket } from "socket.io-client";
import { createServer, type Server as HttpServer } from "http";
import { Server, type Socket as ServerSocket } from "socket.io";
import express, { type Express } from "express";
import type {
  GameState,
  Player,
  RollEvent,
  Effect,
  LastRollEvent,
  ClientToServerEvents,
  ServerToClientEvents,
} from "../src/types/index.js";
```

3. Update source file imports to .ts extension:
```typescript
import { resolveEntry, getEntryById } from "../responseTables.ts";
import {
  clamp,
  clampInt,
  newId,
  ensurePlayerFields,
  hasLiveEffect,
  d6,
  DEFAULT_MAX_HEALTH,
  MAX_HEALTH_CAP,
  MAX_STRESS,
  MAX_RESOLVE,
  ROLL_FEED_CAP,
} from "../utils.ts";
```

4. Define typed Socket.IO aliases near the top (after imports):
```typescript
type TypedClientSocket = ClientSocket<ServerToClientEvents, ClientToServerEvents>;
type TypedServer = Server<ClientToServerEvents, ServerToClientEvents>;
```

5. Type the test variables:
```typescript
describe("Socket.io integration tests", () => {
  let io: TypedServer;
  let clientSocket: TypedClientSocket;
  let httpServer: HttpServer;
  let state: GameState;
```

Note: Do NOT complete full migration in this task. This is infrastructure only.
  </action>
  <verify>Test file should have type imports and aliases defined. Not yet compiling.</verify>
  <done>Type infrastructure added: imports, aliases, variable declarations typed</done>
</task>

<task type="auto">
  <name>Task 2: Type the state and helper functions</name>
  <files>test/server.integration.test.ts</files>
  <action>
1. Type the initial state in beforeAll:
```typescript
beforeAll(async () => {
  state = {
    players: [],
    rollEvents: [],
    missionLog: [],
    metadata: {
      campaignName: null,
      createdAt: null,
      lastSaved: null,
      sessionCount: 0,
    },
  };
```

2. Type the pushRollEvent helper function parameter:
```typescript
function pushRollEvent(ev: RollEvent): void {
  state.rollEvents.push(ev);
  if (state.rollEvents.length > ROLL_FEED_CAP) {
    state.rollEvents.splice(0, state.rollEvents.length - ROLL_FEED_CAP);
  }
}
```

3. Type the broadcast function:
```typescript
function broadcast(): void {
  for (const p of state.players) ensurePlayerFields(p);
  io.emit("state", state);
}
```

4. Type the resolveNextHigherDifferentEntry function:
```typescript
import type { StressTableEntry, PanicTableEntry } from "../src/types/index.js";

function resolveNextHigherDifferentEntry(
  rollType: "stress" | "panic",
  total: number,
  currentEntryId: string | null
): StressTableEntry | PanicTableEntry | null {
  const startId = String(currentEntryId ?? "");
  let t = clampInt(total, -999, 999);
  for (let i = 0; i < 25; i++) {
    t += 1;
    const next = resolveEntry(rollType, t);
    if (next && String(next.id ?? "") && String(next.id ?? "") !== startId)
      return next;
  }
  return null;
}
```

5. Type the beforeEach state reset:
```typescript
beforeEach(() => {
  state = {
    players: [],
    rollEvents: [],
    missionLog: [],
    metadata: {
      campaignName: null,
      createdAt: null,
      lastSaved: null,
      sessionCount: 0,
    },
  };
});
```
  </action>
  <verify>Helper functions typed. State initialization typed.</verify>
  <done>State object and helper functions have explicit types</done>
</task>

<task type="auto">
  <name>Task 3: Type test fixtures and Promise callbacks</name>
  <files>test/server.integration.test.ts</files>
  <action>
1. Type all Promise<GameState> callbacks in tests:
```typescript
const newState = await new Promise<GameState>((resolve) => {
  clientSocket.once("state", resolve);
});
```

2. Type player fixtures in beforeEach blocks:
```typescript
const player: Player = {
  id: "test-player",
  name: "Test Player",
  health: 5,
  maxHealth: 5,
  stress: 3,
  resolve: 1,
  activeEffects: [],
  lastRollEvent: null,
};
state.players.push(player);
```

3. Type effect fixtures:
```typescript
const effect: Effect = {
  id: "effect-123",
  type: "stress_jumpy",
  label: "Jumpy",
  severity: 2,
  createdAt: Date.now(),
  durationType: "manual",
  clearedAt: null,
};
```

4. Type the lastRollEvent fixture in roll:apply tests:
```typescript
const lastRollEvent: LastRollEvent = {
  type: "stress",
  eventId: "test-event-123",
  total: 5,
  die: 5,
  stress: 5,
  resolve: 0,
  modifiers: 0,
  tableEntryId: "stress_frantic",
  tableEntryLabel: "Frantic",
  tableEntryDescription: "Test description",
  tableEntryStressDelta: 0,
  tableEntryPersistent: true,
  duplicateAdjusted: false,
  duplicateFromId: null,
  duplicateFromLabel: null,
  duplicateNote: null,
  applyOptions: null,
  appliedTableEntryId: null,
  appliedTableEntryLabel: null,
  appliedTableEntryDescription: null,
  appliedTableEntryStressDelta: null,
  timestamp: Date.now(),
  applied: false,
  appliedEffectId: null,
  appliedStressDuplicate: false,
  stressDeltaApplied: false,
  stressDeltaAppliedValue: null,
};
```

5. Type the httpServer.address() result:
```typescript
const address = httpServer.address();
const port = typeof address === 'object' && address !== null ? address.port : 0;
```

6. Delete the original .js file after all typing is complete.

7. Run typecheck and fix any remaining type errors.

IMPORTANT: Do NOT change any test logic or assertions. Only add types.
  </action>
  <verify>npm run typecheck && npm test -- test/server.integration.test.ts</verify>
  <done>server.integration.test.ts compiles with strict mode, all 21 tests pass, no any types</done>
</task>

</tasks>

<verification>
Run full test suite to verify no regressions:

```bash
# Type check migrated file
npm run typecheck

# Run integration tests
npm test -- test/server.integration.test.ts

# Verify test count unchanged (21 tests)
npm test -- test/server.integration.test.ts 2>&1 | grep -E "Tests.*passed"
```
</verification>

<success_criteria>
- server.integration.test.ts converted to TypeScript
- Original .js test file deleted
- npm run typecheck passes with no errors
- All 21 integration tests pass
- No `any` types in test file
- TypedClientSocket and TypedServer aliases used
- All Promise callbacks have explicit GameState type
- Player and Effect fixtures properly typed
</success_criteria>

<output>
After completion, create `.planning/phases/06-test-migration-validation/06-02-SUMMARY.md`
</output>
